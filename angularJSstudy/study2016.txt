* 키워드 학습이 매우 중요하다!

SPA(single page application)란 : 특정부분을 ajax로 불러와서 새로고침 없이 동작되는것
프로그램 : 명령어 모음을 ram에 적재 후 cpu가 실행하는 과정

object(객체) : 이름, 값이 쌍으로 이루어진 집합
    객체에 올 수 있는 것 : 문자, 숫자, null, undefined, true/false, 객체리터럴({}), 배열([]), 함수

객체리터럴 : {} <- 로 object화 한 것.
JSON : " "

자바스크립트는 동적 언어. 실행이 되어야 비로소 의미를 갖는다.

스코프 :
호이스팅 :
json(Javascript Object Notation(표기법)) :
함수 :

함수가 선언되면 지역벽수는 삭제됨. 실제로 사라짐.

함수가 실행되면
지역 변수부터 세팅되고
this
argurments
[{parent]}


20160312

변수의 개념 다시 생각할 것. 값이 램에 적재된 주소를 네이밍한 것
값 : 변수 할당, 인자로 전달, 함수의 반환값

4번 문제 관련

. <- obj.
() <- 실행해라(함수


*클로저
    사라졌어야 될 실행컨텍스트에 계속 접근 할 수 있는 것. (지역변수가 없으면, 스코프 체인을 타고 바깥으로 나가서 값을 찾기 때문. 전역까지 올라가서도 없으면 에러.)
    내부함수에서 외부함수의 지역변수에 접근할 수 있음.
    *실행 컨텍스트(EC)

*DOM (Document Object Model)
*컴포넌트 - 구조를 묶어 놓은 단위 ?
*양방향 데이터 바인딩


20160319

* 리플로우 : 레이아웃을 다시 계산.
비용이 큼(느려짐). 성능개선에 매우 중요함.

* 리페인트 : 색칠

render tree 단계에서 브라우저에 보임

컴퓨터상 레이어 구분의 장점 : 인접한레이어만 고려해서 설계하면 됨.
각 레이어에를 호출할 수 있는 프로그램 또는 알고리즘이 api

jquery 등
콜백함수는 제어권을 다른 곳으로 넘김 . 문제 2랑 같이 생각해.

* this
this 또한 호출될 때 결정됨.(호출하는 시점에)
함수를 호출할 때 함수를 프로퍼티로 갖고 있는 객체
1. 함수를 호출한 애가 this가 됨.

* new
new로 생성되는 *생성자(일반적으로 첫글자를 대문자로 선언함)는 생성자를 프로토타입으로 하는 새로운 *인스턴스를 리턴함.
-> 본사 기준으로 가맹점 만든다고 생각해.

* 프로토타입

20160326

*의존성주입 (DI : Dependency Injection)

*콜백
    실행권한을 넘겨줌.
*호스트코드

* MVC 패턴
M : model (data, contents)
V : View (layout)
C : Controller

앵귤러에서는 MV* 임 *에는 모든게 들어갈 수 있음

뷰와 모델은 바인딩 되어 있는데 앵귤러가 사이에 들어가 변화가 일어나면 적용시켜준다 이것이 양방향 데어터 바인딩.

20160402

서버없이 저장 . html5 spec 중 local stroage를 이용하면 가능함.
윈도우 전역객체 중 localStroage가 있음.
인자를 두개 받음 1.key값 2.value
저장 : localStroage.setItem("bookmarks"(key값), 11111 (value = 문자열 숫자 true/false 가능))
가져오기 : localStroage.getItem("bookmarks");
객체를 가져오고 싶으면 ? JSON으로 객체화 시켜주고: jSON.stringify({"href":"nav.com"})

불러올때는 JSON을 파싱한다 : var parsedStr = JSON.parse(abc);

에디터 inteliJ